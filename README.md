# 简单HTTP服务器说明文档

## 概述

>  本程序用C语言实现了一个简单的HTTP服务器，能够处理客户端的GET请求，并返回相应的文件或错误信息。服务器使用多线程处理客户端请求，支持基本的HTTP功能(只能访问静态网页)。
> (更多细节见源码注释)


## 目录

- [简单HTTP服务器说明文档](#简单http服务器说明文档)
  - [概述](#概述)
  - [目录](#目录)
  - [开发思路](#开发思路)
    - [1. 网络通信初始化startUp()](#1-网络通信初始化startup)
    - [2. 循环监听客户端请求，创建线程accept()](#2-循环监听客户端请求创建线程accept)
    - [3. 在新线程中处理客户端请求accept\_request()](#3-在新线程中处理客户端请求accept_request)
  - [主函数main()](#主函数main)
    - [代码示例](#代码示例)
  - [功能概览](#功能概览)
    - [1. 网络通信初始化](#1-网络通信初始化)
    - [2. 错误处理](#2-错误处理)
    - [3. 请求处理](#3-请求处理)
    - [4. 主函数](#4-主函数)
  - [使用说明](#使用说明)
  - [注意事项](#注意事项)

## 开发思路

### 1. 网络通信初始化startUp()

- **目标**: 创建一个能够监听客户端请求的服务器套接字。
- **步骤**:
  1. **初始化网络通信**: 使用 `WSAStartup` 初始化 Windows Socket 库。
  2. **创建套接字**: 使用 `socket` 函数创建一个 TCP 套接字。
  3. **设置端口可复用性**: 使用 `setsockopt` 设置 `SO_REUSEADDR` 选项，允许端口复用。
  4. **绑定套接字和网络地址**: 使用 `bind` 函数将套接字绑定到指定的端口和 IP 地址。
  5. **动态分配端口号**（可选）: 使用 `getsockname` 获取动态分配的端口号。
  6. **设置监听队列**: 使用 `listen` 函数设置监听队列的长度。

### 2. 循环监听客户端请求，创建线程accept()

- **目标**: 监听客户端请求并创建线程处理每个请求。
- **步骤**:
  1. **接受客户端连接**: 使用 `accept` 函数接受客户端连接，创建一个新的套接字用于通信。
  2. **创建线程**: 使用 `CreateThread` 函数创建一个新线程，将新套接字传递给线程函数 `accept_request`。

### 3. 在新线程中处理客户端请求accept_request()

- **目标**: 解析客户端请求，返回相应的文件或错误信息。
- **步骤**:
  1. **读取请求行**: 使用 `get_line` 函数读取客户端请求的第一行。
  2. **解析请求方法**: 从请求行中提取请求方法（如 GET）。
  3. **解析请求的资源路径**: 从请求行中提取请求的资源路径。
  4. **检查资源是否存在**: 使用 `stat` 函数检查请求的资源是否存在。
  5. **发送响应头**: 使用 `headers` 函数发送 HTTP 响应头。
  6. **发送文件内容**: 使用 `cat` 函数发送文件内容。
  7. **处理错误**: 如果资源不存在，使用 `not_found` 函数返回 404 错误页面。

## 主函数main()

- **目标**: 初始化服务器, 开始监听客户端请求, 在新线程中处理客户端请求。
- **步骤**:
  1. **初始化网络通信**: 调用 `startUp` 函数初始化网络通信。
  2. **循环监听客户端请求**: 在循环中使用 `accept` 函数接受客户端连接，并创建线程处理请求。
  3. **处理请求**: 在新线程中调用 `accept_request` 函数处理客户端请求。
  4. **关闭套接字**: 关闭服务器套接字。

### 代码示例

```c
int main() {
    unsigned short port = 80;
    int nServer_sock = startUp(&port);//startUp: 1-初始化网络通信
    printf("服务器正在监听端口: %d\n", port);

    struct sockaddr_in client_addr;
    int nClientLen = sizeof(client_addr);
    while (1) {//2-循环监听客户端请求
        int nClient_sock = accept(nServer_sock, (struct sockaddr*)&client_addr, &nClientLen);
        if (nClient_sock == -1) {
            error_die("accept");
        }

        DWORD dwThreadID = 0;//3-在新线程中处理客户端请求
        CreateThread(0, 0, accept_request, (void*)nClient_sock, 0, &dwThreadID);
    }

    closesocket(nServer_sock);
    return 0;
}
```

流程图：

![image-20240716163051044](https://s2.loli.net/2024/07/16/VNDTCEdmqwhnect.png)


## 功能概览

### 1. 网络通信初始化

- **函数名**: `startUp`
- **参数**: `unsigned short* port`
- **返回值**: `int` (服务器套接字)
- **功能**: 初始化网络通信，创建套接字，设置端口可复用性，绑定套接字和网络地址，动态分配端口号，设置监听队列。

### 2. 错误处理

- **函数名**: `error_die`
- **参数**: `const char* str`
- **功能**: 输出错误信息并终止程序。

- **函数名**: `not_found`
- **参数**: `int nClient`
- **功能**: 处理404错误，返回404页面。

- **函数名**: `unimplement`
- **参数**: `int nClient`
- **功能**: 处理未实现的方法（待完善）。

### 3. 请求处理

- **函数名**: `get_line`
- **参数**: `int nSocket, char* buff, int nSize`
- **返回值**: `int` (实际读取到的字节数)
- **功能**: 从客户端套接字读取一行数据。

- **函数名**: `headers`
- **参数**: `int nClient, const char* cFileType`
- **功能**: 发送响应包的头信息。

- **函数名**: `cat`
- **参数**: `int nClient, FILE* resource`
- **功能**: 把文件内容发送给浏览器。

- **函数名**: `server_file`
- **参数**: `int nClient, const char* fileName`
- **功能**: 把文件从服务器发出去。

- **函数名**: `accept_request`
- **参数**: `LPVOID arg`
- **返回值**: `DWORD`
- **功能**: 处理客户端请求的线程函数。

### 4. 主函数

- **函数名**: `main`
- **功能**: 初始化网络通信，循环监听客户端请求，创建线程处理客户端请求。

## 使用说明

1. **编译**: 使用支持Windows Socket的编译器进行编译。
2. **运行**: 运行编译后的可执行文件，服务器将开始监听指定端口（默认为80）。
3. **访问**: 使用浏览器访问服务器的IP地址和端口，服务器将返回相应的文件或错误信息。

## 注意事项

- 确保服务器文件目录结构正确，且文件权限允许读取。
- 处理未实现的方法（如POST）需要进一步完善。
- 服务器使用多线程处理请求，确保系统资源充足。

